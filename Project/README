/*Start Header
******************************************************************/
/*!
\file README
\author	Yin shuyu, yin.s, 1802075
\co-author Luo Yu Xuan, yuxuan.luo, 1802205
\par yin.s\@digipen.edu
\co-par yuxuan.luo\@digipen.edu
\date Apr 19, 2021
\brief  CS398 Final Project
Copyright (C) 2021 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents without the
prior written consent of DigiPen Institute of Technology is prohibited.
*/
/* End Header
*******************************************************************/

This library is inspired by the one found at http://256.com/sources/md5/ by Gray Watson. It was written as the aforementioned library is under the GPL license and has the annoying RSA preamble; this has been written from reading the 
* Introduction

This is a C++ class that implements the Message Digest Algorithm MD5.  The purpose of the algorithm is to calculate a hash of given bit string. MD5 produces a 16 byte (128 bit) hash.
The MD5 hash has been proven to be cryptographically vulnerable to various attacks (google them), and as such should not be used for security purposes. The intended purpose of this library is for file verification.

* Building The Library

The provided makefile will produce a static lib to link against.
To build it follow these steps:
	1) autoreconf
	2) configure
	3) make
	4) make install
	
You can then 'make check' to run the library's self checks

By default the library will compile with the CXXFLAGS '-g -O2'. For a production library without the debugging symbols, call
make CXXFLAGS=<your_flags_here>

Additionally, the test program can be used as a simple hashing application.
Calling 'md5_t -r -' will generate a signature on the data read from standard in.
Calling 'md5_t -r filename' will generate a signature from the contents of a file.



* Example
c4ca4238a0b923820dcc509a6f75849b

The following program will print one line to stdout:
abc
900150983cd24fb0d6963f7d28e17f72

abc123
e99a18c428cb38d5f260853678922e03

#include <string.h>
#include <cstdlib>
#include <iostream>

#include <md5.h>

int main(int argc, char** argv) {
	const char* BYTES = "abc";

	md5::md5_t md5;
	md5.process(BYTES, strlen(BYTES));
	md5.finish();

	char str[MD5_STRING_SIZE];

	md5.get_string(str);

	for (unsigned int i = 0; i < MD5_STRING_SIZE; i++)
		std::cout << str[i];
}






/*std::cout << "1) Link Dictionary " << "[" << dload << "]" << std::endl;

	std::cout << "2) Load Hash to be Cracked " << " [" << hload << "]" << std::endl;

	std::cout << "3) Crack Hash" << std::endl;

	std::cout << "4) Exit" << std::endl;

	std::cout << "Chose your operation:" << std::endl;

	std::cin >> choice;

	ClearScreen();

	switch (choice) {
	case 1:
		std::cout << "Enter Dictionary Location (E.g. Text.txt): \n";
		std::cin >> dname;

		if (check_dict(dname))
			dload = "Loaded!";
		else { dload = "Unloaded"; std::cout << "Dictionary file does not exist!\n"; }

		pause();
		ClearScreen();

		menu();
		break;

	case 2:
		ClearScreen();

		std::cout << "Enter your MD5 Hash to Crack: " << std::endl;
		std::cin >> chash;


		get_hash(chash);

		pause();
		ClearScreen();

		menu();
		break;

	case 3:
		crack_hash(chash);

		pause();
		ClearScreen();

		menu();
		break;

	case 4:
		exit(EXIT_SUCCESS);

	default:
		std::cout << "Invalid Choice....";

		pause();
		ClearScreen();

		menu();
		break;
	}

	choice = 0;*/





	//Adds the cracked hash to the db list
void addToRecord(std::string cPass) {

	std::ofstream ansf;

	ansf.open("pass.txt", std::ios::app); //Create file if not found

	ansf << cPass << std::endl; //Write the password at the eof

}


int count_file(char filename[15]) {

	//Total Lines/Items
	int num = 0;

	//Load File
	std::ifstream f(filename);
	std::string line;

	//Count the items and increment by one on each item found
	for (int i = 0; std::getline(f, line); ++i) { num++; };

	//Return the total lines
	return num;
}

//Function to check if the hash is already
//cracked and present inside the db
void verifyHash(std::string hash) {

	int count = count_file("pass.txt");

	std::map <std::string, std::string> hashbase;

	std::ifstream upass("pass.txt");

	char pload[35];

	MD5 md5;

	char y[32];

	bool con;

	for (int i = 0; i < count; i++) {

		upass >> pload;

		if (md5.digestString(pload) == hash) {

			hload = "Unloaded";
			std::cout << "Your cracked hash is: " << pload << std::endl;
			break;
		}

		con = false; //Condition  to check if matching fails
	}

	if (!con) {

		chash = hash;
	}
}



//Cracks the given hash by converting
//each dict item to it's equivalent
//hash and then comparing it to the
//original one
void crack_hash(std::string hash) {

	MD5 md5;

	char y[32];

	int words = 0;

	int count = count_file(dname);


	if (hload == "Loaded!" && dload == "Loaded!") {

		std::ifstream dict(dname);

		if (check_dict(dname)) {

			char test[25];

			std::cout << "Cracking..." << std::endl;

			for (int i = 0; i < count; i++) {

				dict >> test;

				words += 1;

				if (md5.digestString(test) == hash) {

					std::cout << "Your cracked string is: " << test << std::endl;

					std::cout << "Words handled: " << words << std::endl;

					addToRecord(test);

					break;

				}
			}

		}
		else {

			std::cout << "Dictionary Location not found!" << std::endl;
		}

	}
	else {

		std::cout << "Either your Dictionary or your Hash is not loaded!" << std::endl;
	}

}
